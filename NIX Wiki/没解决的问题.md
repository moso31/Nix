## NXVT相关

- 现在实际是三管线（主管线、VT管线，Upload管线）串行，没有真正的并行，这可能和管线设计不合理有关。后续必须专门调整，不然VT就没有真正的发挥作用。
- 内存现在还是泄漏的。
- GBuffer里 地形材质的渲染存在大量的2048常量；最好和地形系统适配起来
- 纹理加载有时候会花（每次启动有15%概率复现）
- VTStreaming同时存在两套Fence机制，一个用于限制每帧最多执行一次（NXVTFenceSync），一个用于确保释放资源之前GPU必须完成对应的Compute。
	- 主要聚焦NXVTFenceSync——这是必要的吗？因为CPU层面其实已经有一层限制了。
	- 不一定要解决这个问题但需要想清楚
- VTStreaming每次更新完VTBatch，按DX12的约定好像应该设置UAV barrier / 完成标记，但我没有明确做过，查一下这个要不要改
## NXRG相关

- 希望能将老Pass/Renderer结构完全剔除掉。
- 参考Filament RenderGraph，每个渲染节点都使用独立的材质实例
	- 材质实例的生命周期是独立的，不受RenderGraph控制。
	- NXRG不存在使用材质实例的概念。
	- 目前在一些环境下已经出现了问题（比如原本属材质管理的PSO生命周期，现在由NXRG管理，所以管理NXRG passNode的生命周期时，必须考虑这块的耦合问题）

# NXTexture相关

- 现在的NXTexture里各种资源的创建方式并不统一，有的即刻创建内存，有的之前就创建好了内存，此时只是异步指定内存中特定区域对应当前纹理
	- `NXTexture2D::Create`：异步分配
	- `NXTexture2D::CreateRenderTexture`：即刻创建
	- `NXTexture2D::CreateUAVTexture`：即刻创建
	- `NXTexture2D::CreateSolid`：异步分配
	- `NXTexture2D::CreateNoise`：异步分配
	- `NXTexture2D::CreateHeightRaw`：异步分配
	- `NXTexture2D::CreateByData`：异步分配（好像没用）
	- `NXTextureCube::Create`（RT）：即刻创建
	- `NXTextureCube::Create`（File）：异步分配
	- `NXTexture2DArray::Create`（+2 File 重载）：异步分配
	- `NXTexture2DArray::CreateRT`：即刻创建

# 帧同步问题

- 现在的帧资源同步可能存在退化问题，即实际上虽然给`NXBuffer`使用的是MultiFrame，但是实际设计时，`NXBuffer::SetResourceState()`总是需要确保当前帧的数据加载完成才会进入GPU渲染，导致实际上退化成单帧资源。