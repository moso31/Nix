我正在设计一个DX12资源分配机制。
我的描述符分配器的一部分代码是这么实现的：
#pragma once
#include "DXIncludes.h"
#include "DeadList.h"

namespace ccmem
{
	class NonVisibleDescriptorAllocator : public DeadListAllocator
	{
	public:
		NonVisibleDescriptorAllocator(ID3D12Device* pDevice, uint32_t blockSize);
		virtual ~NonVisibleDescriptorAllocator() {};

		void Alloc(const std::function<void(DeadListTaskResult&)>& callback);
		void Free(uint8_t* pMem);

		uint32_t IncrementSize();

	private:
		ID3D12Device* m_pDevice;
	};
}

其中继承了以下基类：
#pragma once
#include <vector>
#include <list>
#include <functional>
#include <mutex>
#include <cassert>
#include <iostream>

namespace ccmem
{
	struct DeadListTaskResult
	{
		uint8_t* pMemory;
	};

	struct DeadListTask
	{
		std::function<void(DeadListTaskResult&)> pCallback;
		uint8_t* pFreeMem;
	};

	struct DeadListBlock
	{
		uint8_t* pMem;
	};

	class DeadListAllocator
	{
	public:
		// 所谓deadList 其实就是一个记录了空闲内存块的链表
		// blockSize 表示内存块的数量，blockByteSize 表示每个内存块的字节大小
		DeadListAllocator(uint32_t blockByteSize, uint32_t blockSize);
		~DeadListAllocator();

		void Alloc(const std::function<void(DeadListTaskResult&)>& callback);
		void Free(uint8_t* pMem);

		void ExecuteTasks();
		void Print();

	private:
		std::vector<DeadListBlock> m_deadList;
		uint32_t m_currentDeadListIndex;

		uint32_t m_blockByteSize;
		uint8_t* m_pMem;

		std::list<DeadListTask> m_taskList;
		std::mutex m_mutex;
	};
}

这个类为了多线程分配，所以使用了一个lambda表达式用来在ExecuteTasks方法调用之后，触发task的回调任务，即TaskResult，来通知调用者分配的内存地址。
问题在于，我每次在主线程获取到回调函数的时候，都需要通过类型强制转换的做法实现。
我想改良我的代码，使其可以直接获取到转换后的类型，而不是每次都获取一个uint8_t*类型的指针。